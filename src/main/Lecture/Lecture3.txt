트랜잭션 이해
    트랜잭션 - 개념 이해
        데이터 저장을 파일이 아니라 데이터베이스에 저장하는 이유는??
        데이터 베이스가 트랜잭션이라는 개념을 지원하기 때문이다!

        하나의 거래를 안전하게 보장해준다!

        모든 작업이 성공해서 데이터베이스에 반영하는것을 커밋
        하나라도 실패해서 거래 이전으로 되돌리는것을 롤백이라고 한다.

        트랜잭션 ACID
        두 가지 작업을 하나로 묶어서 하나의 작업으로 처리하는것을 원자성(A)이라고 한다.
        데이터 베이스에서 정한 무결성 제약조건을 만족해야하는것을 일관성(C)이라고 한다.
        동시에 실행되는 트랜잭션들이 서로에 영향을 미치지 않도록하는것을 격리성(I)이라고 한다.
        결과가 항상 기록되어야하는것을 지속성(D)이라고 한다.

        격리성을 완벽히 보장하려면 병렬처리가 안된다. 거의 순서대로 실행을 해야하는데 이러면 동시처리 성능이 나빠진다
        그래서 ANSI표준은 격리수준을 4단계로 나누어 정의해놓았다. 우리는 이 설정된 단계중에서 우리에게 맞는 단계를 사용하면 된다.
        보통은 READ COMMITTED 사용 그다음은 REPEATABLE READ 사용 나머지 READ UNCOMMITTED, SERIALIZABLE은 거의 사용하지 않는다.

        ★★하나를 묶을 수 있는것이 핵심!!!

    데이터베이스 연결 구조와 DB 세션
        클라이언트 - 데이터베이스 서버는 커넥션으로 연결된다. 해당 프로세스를 세션이라고 한다.

        세션이 트랜잭션 시작, SQL 실행, 트랜잭션 커밋등을 수행합니다.

    트랜잭션 - DB 예제 1 - 개념 이해
        트랜잭션의 동작개념의 전체 그림 이해가 핵심.

        데이터 변경 쿼리를 실행하고 데이터 베이스에 그 결과 반영할땐 COMMIT, 반영하고 싶지 않으면 ROLLBACK

        커밋을 호출하기 전까지는 임시로 데이터를 저장하는것!

        커밋하지 않은 데이터를 다른 곳에서 조회할 수 있으면 데이터 정합성에 큰 문제가 발생할 수 있다.
        따라서 커밋 전의 데이터는 다른 세션에서 보이지 않는다.

    트랜잭션 - DB 예제 2 - 자동,수동 커밋
        자동 커밋은 트랜잭션기능을 제대로 수행불가 수동을 사용하자.

    트랜잭션 - DB 예제 3 - 트랜잭션 실습
        커밋과 롤백을 사용하여
        세션별로 데이터베이스에서 어떻게 조회되는지 간단한 실습을 통해 살펴보았다.

    트랜잭션 - DB 예쩨 4 - 계좌이체
        커밋과 롤백 실제 예시

    DB 락 - 개념 이해
        트랜잭션의 원자성을 지키기 위해 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를
        수정할 수 없게 막아야 한다!

        이런 문제 해결을 위해 락이라는 개념을 제공!

        락을 획득해야 데이터를 변경할 수 있습니다.

        데이터베이스에 있는 무언가를 수정하려고할때 먼저 요청한쪽에서 락을 획득한다. 그리고 수정한후 커밋하면 락을 반납한다.

    DB 락 - 변경
        락 타임아웃 시간이 설정되어 있어서 대기하다가 정해진 시간이 지나도 락 권한을 획득하지 못하면 에러가 발생한다.

    DB 락 - 조회
        일반적인 조회는 락을 사용하지 않는다!

        어느경우에 조회할때 락을 사용?
        select for update 구문을 사용하면 조회할때도 락을 획득한다.

        트랜잭션 종료시점까지 해당 데이터를 다른곳에서 변경하지 못하도록 강제로 막아야할 때 사용!!!

    트랜잭션 - 적용 1
        DB트랜잭션을 사용해서 원자성이 중요한 비즈니스 로직을 어떻게 구현할까?

        테스트 데이터를 제거해야 다음테스트에 영향을 주지않는다!
        이것보다 더 나은 방법은 트랜잭션을 활용하면 된다.

        예제에서 남은 문제점을 트랜잭션을 활용해 해결해보자

    트랜잭션 - 적용 2
        애플리케이션에서 트랜잭션을 어떤 계층에 걸어야 할까? 어디에서시작하고 어디에서 커밋해야하나?

        비즈니스 로직이 있는 서비스 계층에서 시작해야한다! 문제가 생기면 안되는 부분을 함께 롤백해야하기 때문!!

        트랜잭션은 커넥션이 필요하다 set autocommit false를 해야한다.

        서비스 계층에서 커넥션을 만들고 트랜잭션 커밋 이후에 커넥션을 종료 해야 한다.

        ★★ 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야한다.

        자동커밋을 수동커밋으로 변경하는 것을 트랜잭션을 시작한다고 표현한다.

        끝나고 나서는 자동커밋모드로 변경하는것이 안전하다.

        남은 문제는?
        트랜잭션을 시작하고 커밋하는 코드가 중복되고 너무 지저분해진다.
        트랜잭션 처리하는 코드가 더많다 비즈니스코드보다 주객전도가 되어버림!
        스프링을 활용해서 이런 문제를 해결해보자!!

    정리
