스프링과 문제 해결 - 트랜잭션
    문제점들
        역할에 따라 3가지 계층으로 나눈구조 제일 많이 사용
        프레젠테이션 계층 - UI 관련처리
        서비스 계층 - 비즈니스 로직
        데이터 접근 계층 - DB 접근 처리

        서비스 계층이 제일 중요! 핵심 비즈니스 로직이 들어가 있기 때문!
        시간이 흘러 UI나 데이터 저장기술이 변해도 비즈니스 로직은 최대한 변경없이 유지되어야 한다.

        프레젠테이션 계층은 클라이언트가 접근하는 UI와 관련된 기술인 웹, 서블릿, HTTP와 관련된 부분을 담당
        데이터 접근 계층은 데이터를 저장하고 관리하는 기술 담당

        서비스 계층은 특정 기술에 직접 의존해서는 안된다!

        트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작하는 것이 좋다.

        큰 문제점 3가지
        1. 트랜잭션
        2. 예외 누수
        3. JDBC 반복

        1. JDBC기술이 서비스계층에 많이 들어있다. 데이터 접근 계층에 다 몰아두어야 한다.
        2. 데이터 접근 계층의 예외가 서비스 계층으로 전파
        3. 유사한 코드의 반복!

        스프링에서 이러한 문제점들을 해결!!!

    트랜잭션 추상화
        현재 서비스 계층은 트랜잭션을 위해서 jdbc기술에 의존중 jpa같은 다른 데이터 접근 기술로 변경하면 코드를 전부 변경해야 한다.

        트랜잭션 기능을 추상화하면 이런 문제 해결된다!

        DI를 통해서 주입해주면된다.

        스프링에서 PlatformTransactionManager 인터페이스를 통해 트랜잭션 기능을 추상화하여 제공
        이미 구현체까지 다 제공해준다.

    트랜잭션 동기화
        스프링이 제공하는 트랜잭션 매니저는 2가지 역할을 수행한다.
        1. 트랜잭션 추상화
        2. 리소스 동기화

        쓰레드로컬 : 데이터를 안전하게 보관, 멀티쓰레드 환경에서도 안전하게 사용한다. 트랜잭션 동기화 매니저에 보관

        커넥션을 이제 파라미터로 전달할 필요가 없다. 트랜잭션매니저가 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.

    트랜잭션 문제 해결 - 트랜잭션 매니저 1
        DataSourceUtils.getConnection()의 동작과정
        트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환 없으면 새로 생성해서 반환
        없으면 커넥션 만들고 있으면 있는거 갖다가 사용한다.

        DataSourceUtils.releaseConnection()의 동작과정
        트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지해준다.
        관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다.

    트랜잭션 문제 해결 - 트랜잭션 매니저 2
        스프링 트랜잭션 이해

        트랜잭션 매니저에서 getTransaction()을 호출하면 트랜잭션을 시작한다.
        트랜잭션을 시작하려면 먼저 데이터 베이스 커넥션을 가지고 있어야 한다.
        트랜잭션 매니저는 내부에서 데이터소스를 사용해서 커넥션을 생성
        커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작
        커넥션을 트랜잭션 동기화 매니저에 보관
        트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 그래서 멀티쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.

        이제 jdbc 기술에 의존하지 않지만 PlatformTransaction에 의존하게 된다.

    트랜잭션 문제 해결 - 트랜잭션 템플릿
        반복되는 패턴 try - catch - 성공하면 커밋, 실패하면 롤백이 반복되는데 이건 어떻게 해결?

        return값의 유무에 따라 execute와 executeWithResult를 나뉜다.

        트랜잭션 템플릿의 기본동작은
        비즈니스 로직이 정상 수행되면 커밋한다.
        언체크,런타임 예외가 발생해야 롤백합니다. 그 외의 경우(체크예외)는 커밋한다.

    트랜잭션 문제 해결 - 트랜잭션 AOP 이해
        서비스 계층에 순수한 비즈니스 로직만을 남겨보자!!!

        스프링 AOP를 통해 프록시를 도입!

        프록시는 스프링이 다 만들어준다.

        스프링의 트랜잭션 AOP는 이 @Trasactional 애노테이션을 인식해서 트랜잭션 프록시를 적용해준다.

        비즈니스로직 앞에 프록시를 넣어서 트랜잭션을 실행해준다 정도만 이해하면된다.

    트랜잭션 문제 해결 - 트랜잭션 AOP 적용
        스프링 컨테이너에 사용하려는 기능의 빈들이 들어가있어야 aop등을 사용할 수 있다.

        스프링 aop적용을 위해서는 스프링 컨테이너가 필요하다 @SpringBootTest가 있으면 테스트시 스프링 부트를 통해
        스프링 컨테이너를 생성! 테스트에서 @Autowired를 통해서 빈등록을 한다.

        @TestConfiguration을 통해 테스트용 설정을 만들어서 빈을 등록할 수 있다.
        내가 등록한 빈들을 넣어준다.

        CGLIB라는 라이브러리를 통해서 프록시를 만들어 낸다.

        @Transactionala을 보고 aop적용 대상이라는것을 판단한다. 스프링이

    트랜잭션 문제 해결 - 트랜잭션 AOP 정리
        흐름이해
        @Transactional을 보고 스프링이 트랜잭션을 적용하는 프록시를 만들어야겠구나 하고 AOP프록시를 만든다.
        여기서 트랜잭션을 다 처리한다.

        스프링 컨테이너를 통해 트랜잭션 매니저 획득하고 트랜잭션을 시작한다.

        데이터 소스를 가지고 커넥션을 만들고 수동커밋모드로 변경한다.

        커넥션을 트랜잭션 동기화 매니저에 보관한다.

        이제 AOP프록시에서 실제 서비스 호출(비즈니스 로직) 데이터로직에 접근하는데 SQL변경할때 트랜잭션 동기화 매니저에 보관된
        커넥션을 사용한다.

        선언적 트랜잭션 관리 VS 프로그래밍 방식 트랜잭션 관리
            선언적은 애노테이션을 하나만 선언해서 편리하게 트랜잭션을 적용하는것을 의미
            프로그래밍 방식은 트랜잭션을 적용하려면 코드를 직접 작성해야한다. 테스트코드 사용할때정도 사용 거의 선언전 방식 사용

        이제 남은건 SQLEXCEPTION ! 예외 처리할때 해결할것

    스프링 부트의 자동 리소스 등록
        스프링 부트는 데이터소스를 스프링 빈에 자동으로 등록한다.
        자동으로 등록되는 스프링 빈 이름 dataSource
        개발자가 직접 데이터 소스를 빈으로 등록하면 충돌 때문에 스프링 부트는 데이터 소스를 자동으로 등록하지 않는다.
        (이건 스프링의 특징 중 하나 거의 다 이런식이다.)

        스프링 부트는 적절한 트랜잭션 매니저를 자동으로 스프링 빈에 등록한다.

    정리
