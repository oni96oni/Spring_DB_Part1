스프링과 문제 해결 - 예외 처리, 반복
    체크 예외와 인터페이스
        서비스 계층은 특정 구현 기술에 의존하지않고 순수하게 작성하는것이 바람직하다!
        그러면 예외에 대한 의존도 없애야한다. (SQLException 같은)
        이런 체크 예외를 런타임예외로 전환해서 서비스 계층에 던지면 서비스 계층이 해당 예외를 무시할 수 있기 때문에
        서비스 계층은 특정 기술에 의존하지 않는 순수한 계층이 된다.

        기존에 이렇게 인터페이스 도입못한 이유는 인터페이스에도 throws SQLException 이렇게 선언해줘야 했었기 떄문
        이건 순수한 인터페이스가 아니다! 인터페이스는 안바꾸려고 만드는건데 예외선언 때문에 다 바꾸게 된다.

        런타임 예외는 이런 부분에서 자유롭다. 인터페이스에 런타임 예외를 따로 선언할 필요가 없다.

    런타임 예외 적용
        체크 예외를 런타임 예외로 변환하면서 인터페이스와 서비스 계층의 순수성을 유지할 수 있게 되었다!
        덕분에 향후 JDBC에서 다른 기술로 변경하더라도 서비스 계층의 코드를 변경하지 않고 유지할 수 있다.

        하지만!
        리포지토리에서 넘어오는 특정한 예외의 경우 복구를 시도할 수 있다. (ex. 데이터베이스 커넥션을 다시 얻어서)
        지금은 항상 MyDbException 이라는 예외만 넘어오기 때문에 예외를 구분할 수 없는 단점이 있다.
        특정 상황에는 예외를 잡아서 복구하고 싶으면 예외를 어떻게 구분해서 처리할 수 있을까?

    데이터 접근 예외 직접 만들기
        복구할 수 없는 예외는 예외를 공통으로 처리하는 부분까지 전달되기 때문에 예외로그를 굳이 남기지 않아도 된다.

        남은문제!
        SQL ErrorCode는 각각의 db마다 다 다르다. 결과적으로 db가 바뀔때마다 ErrorCode를 바꿔주어야한다.
        db가 전달하는 오류는 굉장히 다양하다! 이렇게 모든 상황에 맞는 예외를 지금처럼 다 만들어야 할까?!

        이런 문제를 해결하기 위해 스프링은 SQLExceptionTranslator 라는 인터페이스를 제공한다.

    스프링 예외 추상화 이해
        데이터 접근 계층에 대한 여러 예외를 정리해서 일관된 예외 계층을 제공한다.
        각각의 예외는 특정 기술(jdbc나 jpa)에 종속적이지 않게 설계되어 있다.

        DataAccessException은 두가지로 나뉜다.
        1. TransientDataAccessException
            재시도하면 성공할 수 있는 예외
        2. NonTransientDataAccessException
            재시도해도 실패할 것 같은 예외

        스프링은 이 두가지 예외를 기반으로 예외를 추상화하고 있다.

        스프링은 데이터베이스에서 발생하는 오류코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공!!!

        어떻게 각각의 db가 제공하는 ErrorCode를 스프링이 정의한 예외로 변환해주는가?
        sql-error-codes.xml 파일을 참고하자.
        스프링은 이 파일을 기반으로 SQLExceptionTranslator를 구현한 클래스를 만들어서 빈으로 등록해둔다.

        서비스, 컨트롤러 계층에서 예외 처리가 필요하면 스프링이 제공하는 데이터 접근 예외를 사용하면 된다!

    스프링 예외 추상화 적용

        SQLExceptionTranslator를 사용하여 예외를 추상화

    JDBC 반복 문제 해결 - jdbcTemplate
        Repository에서있는 반복적인 코드를 줄이기 위해 스프링은 JdbcTemplate을 제공한다.
        템플릿 콜백 패턴이용!

        굉장히 편하게 이용 가능하다!
        트랜잭션을 위한 커넥션 동기화와 스프링 예외 변환기도 자동으로 실행해준다!

    정리

